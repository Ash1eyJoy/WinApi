#include <Windows.h>
#include <iostream>
#include <tchar.h>
#include <windows.h>
#include <cstring>

LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);   //функция обратного вызова (передача исполняемого кода в качестве одного из параметров другого кода)
TCHAR WinName[] = _T("MainFrame");        //Имя окна
BOOL showName;             //переменная в которой хранится информация о том, нужно ли показывать имя или нет
UINT timer,sec=0, min=0, hour = 0;
LPCTSTR name ;
TCHAR str[3] = "\0", str1[3] = "\0", str2[3] = "\0", time[9] = "\0";
int a = 0;
HDC hDC;

int WINAPI _tWinMain(HINSTANCE This,  // Дескриптор текущего приложения (дескриптор, присваиваемый операционной системой при загрузке приложения)
	HINSTANCE Prev,  // В современных системах всегда 0 (хранение дескриптора предыдущего экземпляра приложения)
	LPTSTR cmd,      // Командная строка (указатель командной строки (LPTSTR эквивалентен TCHAR*(char или wchar_t(представление значения расширенных наборов символов))))
	int mode) 		  // Режим отображения окна (нужна для функции ShowWindow)
{
	HWND hWnd;		// Дескриптор главного окна программы (идентификатор указывающий на окно) 
	MSG msg; 		// Структура для хранения сообщения (структура, в которой хранится информация о сообщении, передаваемом операционной системой окну приложения)
	WNDCLASS wc; 	// Класс окна

	// Определение класса окна (wc - структура, содержащая информацию по настройке окна)
	wc.hInstance = This;                                        // Дескриптор текущего приложения
	wc.lpszClassName = WinName; 				                // Имя класса окна 
	wc.lpfnWndProc = WndProc; 					                // Функция окна 
	wc.style = CS_HREDRAW | CS_VREDRAW; 		                // Стиль окна 
	wc.hIcon = LoadIcon(NULL, IDI_EXCLAMATION);                 // Стандартная иконка 
	wc.hCursor = LoadCursor(NULL, IDC_ARROW); 	                // Стандартный курсор 
	wc.lpszMenuName = NULL; 					                // Нет меню 
	wc.cbClsExtra = 0; 						                    // Нет дополнительных данных класса 
	wc.cbWndExtra = 0; 						                    // Нет дополнительных данных окна 
	wc.hbrBackground = CreateSolidBrush(RGB(127, 255, 212)); 	// Заполнение окна светло берюзового цвета цветом 


	// Регистрация класса окна
	if (!RegisterClass(&wc)) return 0;

	// Создание окна 
	hWnd = CreateWindow(WinName,			        //Функция которая создаёт окно // Имя класса окна 
		_T("Лабораторная 1"), 		// Заголовок окна 
		WS_OVERLAPPEDWINDOW, 		// Стиль окна 
		CW_USEDEFAULT,				// x (горизонтальная позиция окна, тут это заданная по умолчанию позиция (CW_USEDEFAULT))
		CW_USEDEFAULT, 				// y (вертикальная позиция окна)
		700, 				// ширина окна
		500, 				// высота окна
		HWND_DESKTOP, 				// Дескриптор родительского окна 
		NULL, 						// Нет меню (дискриптор меню)
		This, 						// Дескриптор приложения 
		NULL); 					    // Дополнительной информации нет (указатель на данные создания окна)

	ShowWindow(hWnd, mode);                         // Показать окно

	// Цикл обработки сообщений 
	while (GetMessage(&msg, NULL, 0, 0)) {         //цель цикла — получение и обработка сообщений, передаваемых операционной системой

		/*второй параметр hwnd — определяет окно, для которого предназначено сообщение,
		если же необходимо перехватить сообщения всех окон данного приложения, он должен быть NULL;
		остальные два параметра определяют[min, max] диапазон получаемых сообщений.
		Чаще всего необходимо обработать все сообщения, тогда эти параметры должны быть равны 0.*/

		TranslateMessage(&msg); 		           // Функция, которая транслирует код нажатой клавиши в клавиатурные сообщения WM_CHAR
		DispatchMessage(&msg); 		               // Посылает сообщение функции WndProc() (возврат преобразованного сообщения обратно операционной системе)
	}
	return 0;
}


LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam) {      // Оконная функция (возвращает LRESULT ~ long)
	RECT rect;
	GetClientRect(hWnd, &rect);
	PAINTSTRUCT   ps;

	HBRUSH brush;
	static bool flag1 = false;
	static bool flag2 = false;
	
	switch (message)   //Переключатель switch, обеспечивающий выбор соответствующего обработчика сообщений по его номеру message
	{
	case WM_PAINT: 
	{//Сообщение, которое отправляется при запросе для окраски части окна приложения

		hDC = BeginPaint(hWnd, &ps);          // функция рисования контекста устройства (работа с окном вывода) (hwnd-идентификатор окна приложения, hds-идентификатор контекста устройства, ps-структура для работы контекста (PAINTSTRUCT))

		SetTextColor(hDC, RGB(255, 0, 0));        //Макрос RGB получает три аргумента, представляющих красную, зеленую и голубую составляющие (здесь цвет — черный, цвет текста)
		SetBkColor(hDC, RGB(127, 255, 212));      //Здесь цвет самого окна (светло бирюзовый)

		name = "00.00.00";  //Строка 
		int angle = 0; //Угол нанесения теекста (десятые доли градуса) 

		//PLOGFONT plf = (PLOGFONT)LocalAlloc(LPTR, sizeof(LOGFONT));    // Параметры логического шрифта
		//plf->lfWeight = FW_NORMAL;              //Жирность шрифта
		//plf->lfEscapement = angle;              //Угол нанесения текста (десятые доли градуса) 
		//plf->lfOrientation = angle;             //Наклон символов (десятые доли градуса), должен быть равен lfEscapement
		//SetTextAlign(hDC, TA_BASELINE);         //Функция, которая устанавливает выравнивание текста для заданного контекста устройства (TA_BASELINE - опорная точка на базовой линии текста)
		//HGDIOBJ hfnt = CreateFontIndirect(plf);      //функция, которая создаёт логический шрифт (возвращает дискриптор логического шрифта если функция завершена успешно, если завершена с ошибкой, то вернётся NULL)
		//HGDIOBJ hfntPrev = SelectObject(hDC, hfnt);  //отображает логический шрифт в физический (согласует логический шрифт с существующим физическим). Функция, которая выбирает объект в создании контекст устройства (новый объект заменяет предыдущий объект того же самого типа)
		////Если функция завершена успешно, то вернётся дескриптор заменяемого объекта, если завершена с ошибкой, то вернётся NULL (исключение регион)

		TextOut(hDC, 300, 230, name , 23); //функция, которая записывает строку символов в заданном месте, используя текущий выбранный шрифт, цвет фона и цвет текста
		// Принимает дискриптор окна, x-координату начальной позиции, y-координату начальной позиции, строку символов, число символов


		//SelectObject(hDC, hfntPrev); //смысл функции описан в 89 строчке
		//DeleteObject(hfnt);          //удаляет логический шрифт, описанный выше
		//EndPaint(hWnd, &ps);             //функция для освобождения контекста устройства

		

		//break;     //Сообщение посылается если пользователь нажимает левую кнопку мыши, в то время как курсор находится в рабочей области окна. 

		if (flag2 == true) {

			sec++;

			if (sec >= 60) {
				min = min + 1;
				sec = 0;
				if (min >= 60) {
					hour = hour + 1;
					min = 0;
				}
			}


			_itoa_s(min, str, 10);
			_itoa_s(sec, str1, 10);
			_itoa_s(hour, str2, 10);
			//_tcscat_s(time, str2);
			memset(time, '\0', 9);
			if (hour < 10) {
				_tcscat_s(time, "0");
			}
			_tcscat_s(time, str2);
			_tcscat_s(time, ".");
			if (min < 10) {
				_tcscat_s(time, "0");
			}
			_tcscat_s(time, str);
			_tcscat_s(time, ".");
			if (sec < 10) {
				_tcscat_s(time, "0");
			}
			_tcscat_s(time, str1);
			name = time;

			TextOut(hDC, 300, 230, name, 9);
			Sleep(1000);
			//InvalidateRect(hwnd, NULL, TRUE);
		}
			

			
		
		EndPaint(hWnd, &ps);
		break;
	}
	case WM_TIMER:
	{
		
	}
	case WM_QUERYOPEN:
	{//сообщение посылается пиктограмме тогда, когда пользователь запрашивает, чтобы окно было восстановлено в его придыдущем размере и позиции
		return TRUE;
		break;
	}
	case WM_LBUTTONDOWN:
	{
		flag2 = true;
		InvalidateRect(hWnd, NULL, true);
		break;

	}

	case WM_RBUTTONDOWN:
	{
		flag1 = true;
		InvalidateRect(hWnd, NULL, true);
		break;
	}
	case WM_DESTROY:
	{//сообщение отправляется когда окно разрушается
		PostQuitMessage(0);        // функция, которая завершает приложение и передает операционной системе код возврата — 0
								   //В результате цикл обработки сообщений прекращается и происходит завершение работы приложения
		break;
	}
	default:
	{
		return DefWindowProc(hWnd, message, wParam, lParam);    //Все остальные сообщения обрабатываются по умолчанию этой функцией (гарантия обработки каждого сообщения)
	}
	
	}
	return 0;

}



